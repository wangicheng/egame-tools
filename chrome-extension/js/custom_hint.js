/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this extension
*/

(() => {
  // src/entry-points/custom_hint.ts
  {
    let encodeBase64 = function(str) {
      const utf8Encoded = new TextEncoder().encode(str);
      return btoa(String.fromCharCode.apply(null, utf8Encoded));
    }, decodeBase64 = function(encodedStr) {
      const decoded = atob(encodedStr);
      const charCodeArray = decoded.split("").map((char) => char.charCodeAt(0));
      const utf8Decoded = new Uint8Array(charCodeArray);
      return new TextDecoder().decode(utf8Decoded);
    }, initializeEditorAndButton = function() {
      editorContainer = document.createElement("div");
      editorContainer.id = "editorContainer";
      editorContainer.classList.add("editorContainer-hidden");
      editorTextarea = document.createElement("textarea");
      editorTextarea.id = "editorTextarea";
      editorTextarea.placeholder = "自訂提示...";
      editorContainer.appendChild(editorTextarea);
      const cancelBtn = document.createElement("button");
      cancelBtn.id = "cancelBtn";
      cancelBtn.textContent = "取消";
      editorContainer.appendChild(cancelBtn);
      const saveBtn = document.createElement("button");
      saveBtn.id = "saveBtn";
      saveBtn.textContent = "儲存";
      editorContainer.appendChild(saveBtn);
      document.body.appendChild(editorContainer);
      const menu = document.querySelector("div#menu");
      toggleButton = document.createElement("button");
      toggleButton.innerText = "編輯提示";
      toggleButton.title = "編輯提示。";
      menu.insertAdjacentElement("afterbegin", toggleButton);
      saveBtn.addEventListener("click", () => {
        const content = editorTextarea.value.trim();
        hintText = content;
        hideEditor();
      });
      cancelBtn.addEventListener("click", () => {
        editorTextarea.value = "";
        hideEditor();
      });
      document.querySelector("#dialogShadow").addEventListener("click", (event) => {
        if (editorContainer.classList.contains("editorContainer-hidden")) {
          return;
        }
        hideEditor();
      });
      toggleButton.addEventListener("click", () => {
        showEditor();
      });
      const regex = /}\)\("([^"]*)"\);?/m;
      const match = dojoInfo.makerAnswer.match(regex);
      if (match && match[1]) {
        hintText = decodeBase64(match[1]);
      } else {
        hintText = "";
      }
    }, showEditor = function() {
      const shadow = document.getElementById("dialogShadow");
      shadow.style.visibility = "visible";
      shadow.style.opacity = 0.5;
      editorContainer.classList.remove("editorContainer-hidden");
      editorTextarea.value = hintText;
      editorTextarea.focus();
    }, hideEditor = function() {
      const shadow = document.getElementById("dialogShadow");
      shadow.style.opacity = 0;
      window.setTimeout(() => shadow.style.visibility = "hidden", 175);
      editorContainer.classList.add("editorContainer-hidden");
    };
    let hintText = "";
    let editorContainer;
    let editorTextarea;
    let toggleButton;
    const observer = new MutationObserver(function(mutationList, observer3) {
      const codeButton = document.querySelector("#codeButton");
      if (!codeButton) {
        return;
      }
      observer3.disconnect();
      initializeEditorAndButton();
    });
    observer.observe(document.documentElement, { attributes: false, childList: true, subtree: true });
    const observer2 = new MutationObserver(function(mutationList, observer3) {
      const saveForm = document.querySelector("#saveForm");
      if (!saveForm) {
        return;
      }
      observer2.disconnect();
      const submitFunction = saveForm.submit;
      saveForm.submit = function() {
        const makerAnswer = document.querySelector("#makerAnswer");
        if (hintText) {
          makerAnswer.value += `
// custom hint
containerHint.innerHTML = "";
containerHint.innerText = ((encodedStr) => {
  const decoded = atob(encodedStr);
  const charCodeArray = decoded.split('').map(char => char.charCodeAt(0));
  const utf8Decoded = new Uint8Array(charCodeArray);
  return new TextDecoder().decode(utf8Decoded);
})("${encodeBase64(hintText)}");
        `;
        }
        submitFunction.apply(this);
      };
    });
    observer2.observe(document.documentElement, { attributes: false, childList: true, subtree: true });
  }
})();
